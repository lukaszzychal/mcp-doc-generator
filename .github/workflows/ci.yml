name: CI

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'scripts/**'
      - 'Dockerfile'
      - 'docker-compose.yml'
      - 'pyproject.toml'
      - 'requirements.txt'
      - '.github/workflows/**'
      - '.gitleaks.toml'
  pull_request:
    branches: [main]
    paths:
      - 'src/**'
      - 'tests/**'
      - 'scripts/**'
      - 'Dockerfile'
      - 'docker-compose.yml'
      - 'pyproject.toml'
      - 'requirements.txt'
      - '.github/workflows/**'
      - '.gitleaks.toml'
  workflow_dispatch:

jobs:
  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest
    continue-on-error: false
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        continue-on-error: false
        run: |
          docker run --rm \
            -v "${{ github.workspace }}":/path \
            -w /path \
            zricethezav/gitleaks:latest \
            detect \
            --source="/path" \
            --config="/path/.gitleaks.toml" \
            --verbose \
            --exit-code 1


  lint:
    name: Lint and Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: 'pip'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-3.12-${{ hashFiles('**/requirements.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-3.12-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"

      - name: Run ruff check (errors only)
        continue-on-error: true
        run: ruff check src/ tests/ scripts/

      - name: Run black format check
        continue-on-error: true
        run: black --check --diff src/ tests/ scripts/

  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [secret-scan, lint]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create output directory
        run: mkdir -p output

      - name: Build Docker image with cache
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: mcp-documentation-server:latest
          # Użyj cache z GHCR (gdzie docker-build.yml pushuje obrazy) + GitHub Actions cache
          # BuildKit próbuje cache w kolejności: GHCR -> GitHub Actions -> rebuild
          cache-from: |
            type=registry,ref=ghcr.io/${{ github.repository }}/mcp-server:main
            type=gha,scope=mcp-doc-server
          cache-to: type=gha,mode=max,scope=mcp-doc-server
          build-args: |
            BUILDKIT_INLINE_CACHE=1
        # Note: Docker BuildKit używa cache w kolejności:
        # 1. Najpierw próbuje cache z GHCR (jeśli obraz istnieje z docker-build.yml)
        # 2. Potem używa cache z GitHub Actions
        # 3. Jeśli Dockerfile/requirements.txt zmieniły się -> rebuilduje tylko zmienione warstwy
        # 4. Jeśli src/ zmieniło się -> rebuilduje tylko COPY layer
        # To daje dodatkowe ~2-4 min oszczędności gdy obraz już istnieje w GHCR

      - name: Start Docker Compose services
        env:
          COMPOSE_DOCKER_CLI_BUILD: 0
        run: |
          docker compose up -d

      - name: Wait for PlantUML server to be healthy
        run: |
          echo "Waiting for PlantUML server to be ready..."
          timeout=120
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost:8080/ > /dev/null 2>&1; then
              echo "PlantUML server is ready!"
              break
            fi
            echo "Waiting... ($elapsed/$timeout seconds)"
            sleep 5
            elapsed=$((elapsed + 5))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "PlantUML server failed to start within $timeout seconds"
            docker compose logs plantuml
            exit 1
          fi

      - name: Wait for MCP server container to be ready
        run: |
          echo "Waiting for MCP server container to be ready..."
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if docker ps | grep -q "mcp-documentation-server"; then
              echo "MCP server container is running!"
              sleep 2
              break
            fi
            echo "Waiting... ($elapsed/$timeout seconds)"
            sleep 2
            elapsed=$((elapsed + 2))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "MCP server container failed to start within $timeout seconds"
            docker compose logs mcp-server
            exit 1
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-3.12-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-3.12-

      - name: Install Python dependencies for tests
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run MCP server tests
        id: test
        env:
          TEST_DEBUG: "true"  # Enable debug logging
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status
          python3 tests/test_mcp_local.py > /tmp/test_output.log 2>&1
          TEST_EXIT_CODE=$?
          echo "exit_code=$TEST_EXIT_CODE" >> $GITHUB_OUTPUT
          cat /tmp/test_output.log
          if [ $TEST_EXIT_CODE -ne 0 ]; then
            echo "❌ Testy nie przeszły (exit code: $TEST_EXIT_CODE)"
            echo "=== Debug Info ==="
            echo "Checking if containers are running..."
            docker ps --filter "name=mcp" || echo "No MCP containers found"
            echo "Checking MCP server logs..."
            docker logs mcp-documentation-server --tail 50 || echo "Could not read logs"
            exit $TEST_EXIT_CODE
          fi
          echo "✅ Wszystkie testy przeszły"

      - name: Check test output
        if: always()
        run: |
          echo "=== Test Output ==="
          if [ -f /tmp/test_output.log ]; then
            cat /tmp/test_output.log
          fi

      - name: Show Docker logs on failure
        if: failure()
        run: |
          echo "=== PlantUML Server Logs ==="
          docker compose logs plantuml || true
          echo "=== MCP Server Logs ==="
          docker compose logs mcp-server || true

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            /tmp/test_output.log
            /tmp/mcp_test_results.json
            output/*
          retention-days: 7

      - name: Cleanup Docker containers
        if: always()
        run: |
          docker compose down -v
          docker system prune -f

